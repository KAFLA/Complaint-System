# System Obsługi ReklamacjiStreszczenie projektuProjekt zrealizowany w ramach przedmiotu "Programowanie Obiektowe". Jest to zaawansowana aplikacja desktopowa typu CRUD, zbudowana w technologii .NET (WPF), przeznaczona do kompleksowego zarządzania procesem reklamacyjnym w firmie. System implementuje architekturę wielowarstwową, wzorzec projektowy MVVM oraz zaawansowany, oparty na rolach, system kontroli dostępu (RBAC).🏛️ Zastosowanie paradygmatów programowania obiektowegoProjekt został świadomie zaprojektowany z wykorzystaniem fundamentalnych zasad programowania obiektowego, aby zapewnić jego skalowalność, elastyczność i łatwość w utrzymaniu.📦 Enkapsulacja (Hermetyzacja)Zasada enkapsulacji została zrealizowana poprzez tworzenie klas, które łączą w sobie zarówno dane (pola, właściwości), jak i operacje na nich (metody).Modele danych (User, Complaint): Stan wewnętrzny obiektów jest chroniony. Dostęp do danych odbywa się wyłącznie poprzez publiczne właściwości (properties) z logiką walidacji, co zapobiega wprowadzaniu niepoprawnych danych.Serwisy (AuthService, PermissionService): Wewnętrzna logika i mechanizmy (np. sposób hashowania hasła) są ukryte przed resztą aplikacji. Udostępniają jedynie publiczne API (metody), które można bezpiecznie wywoływać.🧩 AbstrakcjaAbstrakcja pozwoliła na ukrycie złożoności implementacyjnej i udostępnienie prostego, zrozumiałego interfejsu.Wzorzec Repozytorium (BaseRepository<T>): Zdefiniowano generyczny interfejs IRepository<T> oraz klasę bazową BaseRepository<T>, które abstrahują od konkretnej technologii dostępu do danych (ADO.NET z MySQL). Dzięki temu, logika biznesowa operuje na abstrakcji repozytorium, nie wiedząc, jak dokładnie realizowane są operacje na bazie danych. Zmiana silnika bazy danych wymagałaby jedynie modyfikacji w warstwie repozytoriów.🧬 DziedziczenieMechanizm dziedziczenia został wykorzystany do ponownego użycia kodu i budowania hierarchii klas.Repozytoria (UserRepository, ComplaintRepository): Klasy te dziedziczą po generycznej klasie BaseRepository<T>, dzięki czemu współdzielą podstawową implementację operacji CRUD (Create, Read, Update, Delete), jednocześnie mogąc rozszerzać ją o specyficzne dla siebie metody (np. GetUserByUsername).ViewModele: Możliwe jest stworzenie klasy bazowej BaseViewModel, która implementuje interfejs INotifyPropertyChanged i jest następnie rozszerzana przez wszystkie inne ViewModele w aplikacji, co eliminuje powtarzanie kodu.🎭 PolimorfizmPolimorfizm, głównie w połączeniu ze wzorcem strategii, umożliwił elastyczne zarządzanie różnymi zachowaniami systemu.System Uprawnień (PermissionService): Chociaż w obecnej implementacji może być to rozwiązane warunkowo, architekturę można łatwo rozbudować. Można zdefiniować interfejs IPermissionStrategy z metodą CanExecute(), a następnie stworzyć konkretne implementacje dla każdej roli (AdminStrategy, ManagerStrategy). PermissionService w zależności od roli zalogowanego użytkownika używałby odpowiedniego obiektu strategii do decydowania o dostępie, co jest klasycznym przykładem polimorfizmu.🏗️ Architektura i wzorce projektoweSystem został oparty o sprawdzoną architekturę wielowarstwową oraz nowoczesne wzorce projektowe, co zapewnia separację odpowiedzialności (Separation of Concerns).Warstwa Prezentacji (View): Zbudowana w WPF, odpowiedzialna wyłącznie za wyświetlanie danych i przechwytywanie interakcji użytkownika.Warstwa Logiki Prezentacji (ViewModel): Sercem aplikacji jest wzorzec MVVM (Model-View-ViewModel). ViewModele zawierają całą logikę prezentacji, zarządzają stanem widoku i komunikują się z warstwą usług. Wykorzystują mechanizmy Data Binding oraz Commands do komunikacji z widokiem.Warstwa Logiki Biznesowej (Services): Zawiera kluczową logikę aplikacji, niezależną od interfejsu użytkownika. Przykładem jest AuthService zarządzający uwierzytelnianiem.Warstwa Dostępu do Danych (Repositories): Implementacja wzorca Repozytorium, która abstrahuje i centralizuje dostęp do źródła danych. Zapewnia to izolację logiki biznesowej od specyfiki bazy danych.Dodatkowo, zastosowano wzorzec Strategii w systemie uprawnień oraz mechanizm wstrzykiwania zależności (Dependency Injection) w sposób koncepcyjny, aby poszczególne komponenty były od siebie luźno powiązane.📋 Główne funkcjonalnościSystem uwierzytelniania i autoryzacji:Rejestracja i logowanie użytkowników.Bezpieczne przechowywanie haseł z użyciem BCrypt.NET.Trzy role użytkowników: Admin, Manager, Employee z granularnymi uprawnieniami.Zarządzanie reklamacjami:Pełen cykl życia reklamacji (CRUD).System statusów (Nowa, W toku, Rozwiązana, Zamknięta).Przypisywanie reklamacji do pracowników i definiowanie priorytetów.Repozytorium rozwiązań:Baza wiedzy z gotowymi rozwiązaniami typowych problemów.Możliwość wyszukiwania i zarządzania rozwiązaniami.🚀 Instalacja i uruchomienieWymagania wstępne.NET 8.0 SDKMySQL Server 8.0+Opcjonalnie: Visual Studio 2022Kroki instalacyjneSklonuj repozytorium:git clone https://github.com/twoja-nazwa/reklamacje-system.git

# cd reklamacje-system

# Konfiguracja bazy danych:Utwórz bazę danych w MySQL.CREATE DATABASE reklamacje\_db CHARACTER SET utf8mb4 COLLATE utf8mb4\_unicode\_ci;

# Uruchom skrypt Database/schema.sql (lub podobny), aby utworzyć wszystkie niezbędne tabele.Konfiguracja połączenia:W odpowiednich plikach (np. App.xaml.cs lub w plikach repozytoriów) zaktualizuj connectionString, podając dane dostępowe do Twojej bazy danych.string connectionString = "server=localhost;database=reklamacje\_db;user=twoj\_uzytkownik;password=twoje\_haslo;";

# Uruchomienie aplikacji:dotnet run --project ReklamacjeSystem

# 📸 Zrzuty ekranuTutaj umieść zrzuty ekranu, np.:\[Ekran logowania]Opis: Czysty i nowoczesny interfejs logowania.\[Panel główny z listą reklamacji]Opis: Widok prezentujący listę reklamacji z możliwością filtrowania i sortowania.👥 AutorImię i NazwiskoNumer Indeksu: 123456

